---
layout: post
title:  "Python Applications - Summary 1-4"
description: I write Python!
date:   2'0'16-11-05 00:00:00 
categories: book  
img: CPAP.jpg
categories: [one, two]
color: 000555 
author: Desgard_Duan
---

最近开始阅读经典的 *Core Python Application Programming* 。以下是第 1-4 章总结.

## 正则表达式

* Compile or Not Compile

在 Python 的编译环境中，Python 代码会被编译成字节码，然后再编译器上执行。特别是，指定 `eval()` 或者 `exec()` 调用一个代码对象而不是一个字符串，性能上回有明显的提升。这是因为对于前者而言，编译过程不会重复执行。即使用预编译的代码对象比直接使用字符串要快，因为解释器在执行字节串形式的代码前都必须把字符串编译成代码对象。

同样的概念也存在于**正则表达式**中——在模式匹配发生之前，正则表达式模式必须编译成正则表达式对象。由于正则表达式在执行过程中将进行多次比较操作，因此**强烈建议使用预编译**。而且，既然正则表达式编译是必须的，那么使用预编译来提升执行性能无疑是明智之举。`re.compile()` 能够提供此功能。

* 正则缓存机制

模块函数会对已编译的对象进行缓存，所以不是所有使用相同正则表达式模式的 `search()` 和 `match()` 都需要编译。即时这样，你也节省了缓存查询时间，并且不必对于相同的字符串反复进行函数调用。在不同的 Python 版本中，缓存中已编译过的正则表达式对象的数目可能不同，而且没有文档记录。`purge()` 函数能够用于清除这些缓存。

* 关于正则表达式的学习体会

这两天无论在看 *Core Python Application Programming* 还是在做 **HackSwjtu** 的项目，接触最多的东西无疑是**正则表达式**。由于在网络数据中，有较多的文本（多为 HTML）需要提取处理。在 `lxml` 或 `html5lib` 的三方库无法解决问题时，则需要自己创造模式串，进行正规则则匹配。

学习流程需要从以下几点：

1. re 模块基本方法（包括 `compile`, `group`, `match`等）
2. 匹配练习与记忆
3. 常用正则串的阅读和思路学习
4. 理解贪婪和非贪婪模式
5. 杂项

最后，希望给自己布置一个大作业。个人认为该书的 *1-32* 对于 *Amazon 爬虫脚本* 是个很不错的选择。但是现在 Amazon 有了反爬虫机制，所以有的时候（大量时间）会有问题。所以建议找一个个人喜爱的网站进行训练，例如笔者的 **豆瓣电影 TOP100 爬虫脚本**。[Gist Link](https://gist.github.com/Desgard/71a3ff26a5f3223a25f6a91d2e17d11d)

## 网络编程

* Socket 的认识

在书中 *Socket* 翻译为*嵌套字*，在 Socket 中又可分为面向连接和无连接两种，也就是我们常说的 *TCP* 和 *UDP* 。TCP 通信是提供序列化的，可靠的和不重复的数据交付，而没有记录边界。这基本上意味着每条消息可以拆分成多个片段，并且每一条消息片段都确保能够到达目的地，然后将它们按顺序组合在一起，最后将完整消息传递给正在等待的应用程序。

为了创建 TCP Socket，必须使用 `SOCK_STREAM` 作为嵌套字类型。TCP 嵌套字的名字 `SOCK_STREAM` 基于流套接字的其中一种表示。因为这些套接字 `AF_INET` 网络版本使用 IP 来搜寻网络的主机，所以整个系统通常结合 (TCP 和 IP) 两种协议来进行。

而 UDP 在通信开始之前并不需要简历链接。此时在数据传输过程中并无法保证它的顺序性、可靠性或重复性。然而，数据报确实保存了记录边界，这就意味着消息是以整体发送的，而并非首先分成多个片段。为了创建 UDP 嵌套字，必须使用 `SOCK_DGRAM` 作为嵌套字类型。

* 创建 TCP Server, TCP Client

创建一个 TCP Server，一般要经历以下流程：

1. 创建服务器和嵌套字
2. 嵌套字与地址绑定
3. 监听连接
4. 服务器无线循环
5. 接受客户端连接
6. 通信循环
7. 对话（接受/发送）
8. 关闭客户端嵌套字
9. 关闭服务器嵌套字（op）

一旦进入服务器的无线循环之中，就开始等待 client 的连接。当一个连接请求出现时，我们进入对话循环中，在该循环中我们等待客户端发送的消息。

{% highlight ruby %}
# -*- coding: utf-8 -*-

from socket import *
from time import ctime

# HOST 是对 bind 方法的表示，表示它可以使用任何可用地址
HOST = '127.0.0.1'
# 端口号
PORT = 21567
# 缓存区大小，这里使用 1KB
BUFSIZ = 1024
ADDR = (HOST, PORT)

# 分配 TCP 服务嵌套字类型
tcpSerSock = socket(AF_INET)
# 将嵌套字绑定到服务器地址
tcpSerSock.bind(ADDR)
# 开启 TCP 监听器
tcpSerSock.listen(5)


while True:
    print('waiting for connection...')
    # 接受 client 连接请求
    tcpCliSock, addr = tcpSerSock.accept()
    print('...connected from:', addr)

    while True:
        # 得到反馈数据，将其格式化
        data = tcpCliSock.recv(BUFSIZ)
        if not data:
            break
        # 返回数据并加上时间戳响应
        show =  tcpCliSock.send('[%s] %s' % (ctime(), data))
        print(str(data))
    tcpCliSock.close()
tcpSerSock.close()

{% endhighlight %}


> *练习2-5* *网络互连和嵌套字。* 实现 Python 库参考文档中关于 socket 莫空中的 TCP 服务端/服务器程序事例，并使其能够正常工作。更新服务器代码，以使它具有更多功能，令其能够实现以下命令。

通过简单的 TCP 方式建立 server 和 client，然后使用 os 包，调用方法即可。

* [Gist Link](https://gist.githubusercontent.com/Desgard/71a3ff26a5f3223a25f6a91d2e17d11d/raw/ae4c9643be02db69813463cfac960008ea9fc867/CPAP%25202-15-1%2520Cmd%2520Server)
* [Gist Link](https://gist.githubusercontent.com/Desgard/71a3ff26a5f3223a25f6a91d2e17d11d/raw/ae4c9643be02db69813463cfac960008ea9fc867/CPAP%25202-15-1%2520Cmd%2520Client)


